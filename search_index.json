[
["index.html", "Notes Notes 1 目录", " Notes Miao YU 2016-09-20 Notes 1 目录 01-09：数据科学相关 "],
["the-data-scientists-toolbox.html", "Notes 2 The Data Scientist’s Toolbox 2.1 链接", " Notes 2 The Data Scientist’s Toolbox CLT name of root is represented by a slash: / home directory is represented by a tilde: ~ pwd print working directory recipe: command -flags arguments clear: clear out the commands in your current CLI window ls lists files and folders in the current directory -a lists hidden and unhidden files and folders -al lists details for hidden and unhidden files and folders cd stands for “change directory” cd takes as an argument the directory you want to visit cd with no argument takes you to your home directory cd .. allows you to chnage directory to one level above your current directory mkdir stands for “make directory” touch creates an empty file cp stands for “copy” cp takes as its first argument a file, and as its second argument the path to where you want the file to be copied cp can also be used for copying the contents of directories, but you must use the -r flag rm stands for “remove” use rm to delete entire directories and their contents by using the -r flag mv stands for “move” move files between directories use mv to rename files echo will print whatever arguments you provide date will print today’s date git $ git config --global user.name &quot;Your Name Here&quot; # 输入用户名 $ git config --global user.email &quot;your_email@example.com&quot; # 输入邮箱 $ git config --list # 检查 $ git init # 初始化目录 $ git add . # 添加新文件 $ git add -u # 更新改名或删除的文件 $ git add -A|git add --all # 添加所有改动 $ git commit -m &quot;your message goes here&quot; # 描述并缓存本地工作区改动到上一次commit $ git log # 查看commit记录 用Q退出 $ git status # 查看状态 $ git remote add # 添加服务器端地址 $ git remote -v # 查看远端状态 $ git push # 将本地commit推送到github服务器端 $ git pull|fetch|merge|clone # 本地获取远端repo $ exit # 退出 Git = Local (on your computer); GitHub = Remote (on the web) 基本问题 描述分析：对数据进行描述但不解释 探索分析：寻找未知的变量间关系 （相关不代表因果） 推断分析：用小样本推断总体 统计模型的目标 强依赖采样过程 预测分析：用一组变量预测另一变量 不一定有因果关系 因果分析：改变一个变量引发另一个变量变化的分析 随机实验 平均效果 机理分析：对个体改变一个变量所导致另一个变量的精确变化 公式模拟与参数拟合 数据次于问题 大数据依赖科学而不是数据 实验设计 重视可重复性随机与分组 预测与推断不同 不要选数据 2.1 链接 统计问题 R问题 R mailling ist 数据分享 "],
["r-programming.html", "Notes 3 R Programming 3.1 Overview and History of R 3.2 获得帮助 3.3 数据类型及基本运算 3.4 截取数据 3.5 读取数据 3.6 控制结构 3.7 函数 3.8 编程标准 3.9 范围规则 3.10 向量化操作 3.11 日期与时间 3.12 循环 3.13 模拟 3.14 调试 3.15 分析代码", " Notes 3 R Programming 3.1 Overview and History of R R语言是S语言的一种方言 1976年S是John Chambers等在贝尔实验室作为Fortran的扩展库开发出来的 1988年用C语言重写 S3方法 白皮书 1993年StatSci从贝尔实验室获得S语言的独家开发售卖许可 1998年S4方法 绿皮书 之后S语言稳定 获得Association for Computing Machinery’s Software System Award 2004年Insightful（原StatSci）从Lucent收购了S语言 2006年Alcatel收购了Lucent成立Alcatel-Lucent 2008年TIBCO收购Insightful 之前Insightful开发并售卖S-PLUS 1991年Ross Ihaka与Robert GentlemanNew在Zealand开发了R 1993年发布R第一份许可 1995年R作为自由软件发放GUN许可 1996年R邮件列表创立 1997年R Core成立 控制R源码 2000年R version 1.0.0 放出 2013年R version 3.0.2 放出 R由CRAN掌控的base包与其他包组成 其余参考R主页 3.2 获得帮助 help() ?command # 提问给出以下信息 version str(.Platform) 3.3 数据类型及基本运算 所有数据都是对象 所有对象都有类型 基本类型包括：字符“” 数字 整数L 复数(Re实部 Im虚部) 逻辑 向量储存同一类型数据 list存储不同类型数据 [[*]]引用相应向量 unlist 可用做紧凑输出 对象可以有属性attributes 对象赋值符号为 &lt;- 赋值同时展示加括号或直接输入对象名 可累加赋值 a &lt;- b &lt;- c #表示注释 不执行 : 用来产生整数序列 也可以用seq生成 向量用c产生 空向量用vector()函数建立 向量中类型不同的对象元素会被强制转换为同一类型 字符优先级最高 其次数字 其次逻辑(0 or 1) 也可以用来串联字符 可使用as.*来强制转化数据类型 对象可以用names命名 变量名开头不能是数字和. 大小写敏感 下划线不要出现在名字里 分割用. 变量名中不能有空格 保留字符 FALSE Inf NA NaN NULL TRUE break else for function if in next repeat while 清空rm(list = ls()) 矩阵 带有dimension属性的向量为矩阵 矩阵的生成次序为upper-left matrix(1:6,nrow=2,ncol=3)表示建一个2行3列矩阵 从1到6 先列后行赋值 可用 byrow = T 来更改 可用c给dim赋值行和列数 这样可把一个向量转为一个矩阵 m&lt;-1:6;dim(m)&lt;-c(2,3) 矩阵可以用rbind或cbind生成 t对矩阵转置 因子变量表示分类数据 用标签名区分 用level来命名排序 默认是字母排序 有些函数对顺序敏感可用 levels = c() 来命名 ( 例如低中高的排序 ) 数字表示 drop = T 表示显示截取数据的水平 nlevels给出个数 NaN表未定义或缺失值 NA表示无意义转换或缺失值 NaN可以是NA反之不可以 NA有数据类型 is.NaN与is.NA 可用来检验 数据框 特殊list 每个元素长度相等 每一列类型相同 矩阵所有数据类型相同 特殊属性row.names 转为矩阵data.matrix 变量名自动转化 可以不同 因子变量保持为字符可以用 I data.frame(x,y,I(c)) 数组 表示更高维度的数据 dim() = c(x,y,z) 三维数组表示一组数 dimnames 给数组命名 数组调用如果只有一行 需要drop = F 否则 不会按照数组分类 ts 产生时间序列对象 .Last.value 引用前一个数值 取整数 用round(x,n) n表示保留几位小数 截取整数 trunc 开平方 sqrt 绝对值 abs 指数函数 exp 自然对数函数 log 以 10 为底的对数函数 log10 三角函数 sin cos tan asin acos atan 常用的逻辑运算符有: 大于 &gt; 小于 &lt; 等于 == 小于或等于 &lt;= 大于或等于 &gt;= 与 &amp; 非 ! 或| 判断向量x中是否与y中元素相等 x %in% y 结果返回逻辑值 sum 求和 prod 求连乘 range 给极值范围 duplicated 给出有重复的值 unique 给出无重复的值 向量操作 union 并集 intersect 交集 setdiff 除了交集的部分 rep 用向量循环生成向量 x &lt;- 1:4 # puts c(1,2,3,4) into x i &lt;- rep(2, 4) # puts c(2,2,2,2) into i y &lt;- rep(x, 2) # puts c(1,2,3,4,1,2,3,4) into y z &lt;- rep(x, i) # puts c(1,1,2,2,3,3,4,4) into z w &lt;- rep(x, x) # puts c(1,2,2,3,3,3,4,4,4,4) into w 整型变量后面加上L x&lt;-10L Inf代表1/0 同样1/Inf运算结果为0 3.4 截取数据 []截取数据 可以用[x,y]提取特定数值 [-1,-2]可剔除第一行第二列 [[]]用来从list或者frame里提取元素 类型固定 可提取序列x[[1]][[3]] 可部分匹配 exact=FALSE $用名字提取元素 可部分匹配 提取矩阵时默认只能提取向量 但可以提取1*1矩阵x[1,2,drop=FALSE] 先用is.NA()提取 用!排除 缺失值可用is.element(x,y)来处理很多表示NA值的数字 返回x %in% y的逻辑值 用complete.cases()提取有效数据用[]提取可用数据 head(x,n) n表示从头截取多少行 tail(x,n) n表示从尾截取多少行 subset(x,f) x表示数据 f表示表达式 条件筛选中获得一个变量多个数值的数据使用 [is.element(x,c(' ',' ',' ')),] 或者[x%in%c(' ',' ',' '),] 使用x == c( ' ' , ' ' , ' ' ) 会报错 循环查找三个变量 x!='t' 可能会把空白值输入 应该使用is.element(x,'t') ifelse(con,yes,no) 利用条件筛选 返回yes 或者no 的值 支持正则表达式 3.5 读取数据 read.table read.csv 读取表格 反之write.table readLines 读取文本行 反之writeLines source 读取R代码 反之dump dget 读取多个R代码 反之dput load 读取保存的工作区 反之save unserialize 读取二进制R对象 反之serialize 设置工作目录 getwd() setwd() ?read.table 大数据读取提速 计算内存 comment.char = &quot;&quot; 不扫描注释 设定nrows 设定colClasses initial &lt;- read.table(&quot;datatable.txt&quot;, nrows = 100) classes &lt;- sapply(initial, class) tabAll &lt;- read.table(&quot;datatable.txt&quot;, colClasses = classes) 使用connections与file等保存外部文件指向 3.6 控制结构 if else 条件 if(&lt;condition&gt;) { ## do something } else { ## do something else } if(&lt;condition1&gt;) { ## do something } else if(&lt;condition2&gt;) { ## do something different } else { ## do something different } `for‵ 执行固定次数的循环 嵌套不超过2层 for(i in 1:10) { print(i) } while 条件为真执行循环 条件从左到右执行 count &lt;- 0 while(count &lt; 10) { print(count) count &lt;- count + 1 } repeat 执行无限循环 配合break 中断并跳出循环 next 跳出当前循环继续执行 for(i in 1:100) { if(i &lt;= 20) { ## Skip the first 20 iterations next } ## Do something here } return 退出函数 避免使用无限循环 可用apply替代 3.7 函数 f &lt;- function(&lt;arguments&gt;) { ## Do something interesting } 函数中参数默认值可用formals()显示 参数匹配 先检查命名参数 然后检查部分匹配 最后检查位置匹配 定义函数时可以定义默认值或者设为NULL 懒惰执行：只执行需要执行的语句 ... 向其他函数传参 之后参数不可部分匹配 3.8 编程标准 使用文本文档与文本编辑器 使用缩进 限制代码行宽 80为宜 限制单个函数长度 3.9 范围规则 自由变量采用静态搜索 环境是由数值符号对组成 每个环境都有母环境 函数与环境组成环境闭包 首先从函数环境中寻找变量 之后搜索母环境 最高层为工作区 之后按搜寻列表从扩展包中寻找变量 最后为空环境 之后报错 可以函数内定义函数 S都存在工作区 函数定义一致 R存在内存 可根据需要调用函数环境 3.10 向量化操作 向量操作针对元素 矩阵操作也针对元素 %*% 表示矩阵操作 3.11 日期与时间 日期以data类型存储 时间以POSIXct 或 POSIXlt 类型存储 数字上是从1970-01-01以来的天数或秒数 POSIXct以整数存储时间 POSIXlt以年月日时分秒等信息存储时间 strptime as.Date as.POSIXlt as.POSIXct用来更改字符为时间 3.12 循环 3.12.1 lapply 对列表对象元素应用函数 可配合匿名函数使用 x &lt;- list(a = 1:5, b = rnorm(10)) lapply(x, mean) ## $a ## [1] 3 ## ## $b ## [1] -0.3024154 x &lt;- 1:4 lapply(x, runif, min = 0, max = 10) ## [[1]] ## [1] 8.358008 ## ## [[2]] ## [1] 9.191535 3.785676 ## ## [[3]] ## [1] 4.5560474 4.6964109 0.7888978 ## ## [[4]] ## [1] 4.361288 6.732078 9.793194 4.255967 x &lt;- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) lapply(x, function(elt) elt[,1]) ## $a ## [1] 1 2 ## ## $b ## [1] 1 2 3 3.12.2 sapply lapply的精简版 如果结果是单元素列表 转化为向量 如果结果是等长向量 转化为矩阵 否则输出依旧为列表 x &lt;- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5)) sapply(x, mean) ## a b c d ## 2.5000000 -0.0523202 1.1859010 5.1351221 3.12.3 vapply 类似lapply可用更复杂函数 返回矩阵 3.12.4 replicate 用于将函数循环使用 如返回随机矩阵 3.12.5 rapply 用how来调整输出方法 如选取某列表中类型数据进行迭代 3.12.6 apply 数组边际函数 常用于矩阵的行列处理 行为1，列为2 可用rowSums rowMeans colSums colMeans 来替代 大数据量更快 x &lt;- matrix(rnorm(50), 10, 5) apply(x, 1, quantile, probs = c(0.25, 0.75)) ## [,1] [,2] [,3] [,4] [,5] [,6] ## 25% -0.8254379 -0.2968362 -0.86962860 -0.7789611 -0.2738811 -0.07775356 ## 75% -0.1439351 0.5749372 0.05064879 -0.7082354 0.2918599 1.22574882 ## [,7] [,8] [,9] [,10] ## 25% -0.3432042 0.0487463 -1.208470797 -0.587165776 ## 75% 0.9441855 0.9682276 0.007929283 0.008335851 a &lt;- array(rnorm(2 * 2 * 10), c(2, 2, 10)) apply(a, c(1, 2), mean) ## [,1] [,2] ## [1,] 0.15308218 0.3462083 ## [2,] -0.08866618 -0.1813021 3.12.7 tapply 对数据子集（因子变量区分）向量应用函数 x &lt;- c(rnorm(10), runif(10), rnorm(10, 1)) f &lt;- gl(3, 10) tapply(x, f, mean) ## 1 2 3 ## 0.5829884 0.4615180 0.4604292 3.12.8 by 对数据按照因子变量应用函数 类似tapply 按照某个分类变量a分类求均值 by(x[,-a],a,mean) 3.12.9 split 将数据按因子分割为列表 常配合lapply使用 类似tapply 可用来生成分组 用drop来删除空分组 x &lt;- c(rnorm(10), runif(10), rnorm(10, 1)) f &lt;- gl(3, 10) lapply(split(x, f), mean) ## $`1` ## [1] 0.4439831 ## ## $`2` ## [1] 0.260168 ## ## $`3` ## [1] 1.034931 x &lt;- rnorm(10) f1 &lt;- gl(2, 5) f2 &lt;- gl(5, 2) str(split(x, list(f1, f2), drop = TRUE)) ## List of 6 ## $ 1.1: num [1:2] -0.00498 -0.41599 ## $ 1.2: num [1:2] 0.732 -1.27 ## $ 1.3: num 0.543 ## $ 2.3: num -1.33 ## $ 2.4: num [1:2] -0.511 0.4 ## $ 2.5: num [1:2] 0.474 0.48 3.12.10 mapply 多变量版apply 从多个参数范围取值 并用函数得到结果 noise &lt;- function(n, mean, sd) { rnorm(n, mean, sd) } mapply(noise, 1:5, 1:5, 2) ## [[1]] ## [1] 1.01803 ## ## [[2]] ## [1] 1.043653 2.615398 ## ## [[3]] ## [1] 5.937356 3.722024 2.723210 ## ## [[4]] ## [1] 4.484918 6.982466 2.681435 2.684598 ## ## [[5]] ## [1] 5.828498 5.119153 6.255227 3.672385 5.841349 #等同于如下循环 #list(noise(1, 1, 2), noise(2, 2, 2), # noise(3, 3, 2), noise(4, 4, 2), # noise(5, 5, 2)) 3.12.11 eapply 对环境变量应用函数 用于包 3.13 模拟 在某分布下产生随机数 d 分布概率密度 r 分布随机数 p 分布累计概率 q 分布分位数 dnorm(x, mean = 0, sd = 1, log = FALSE) pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) rnorm(n, mean = 0, sd = 1) set.seed保证重现性 sample对数据采样 3.14 调试 三种提示 message warning error 只有error致命 关注重现性 调试工具 traceback debug browser trace recover 三思而行 3.15 分析代码 先设计 后优化 system.time 计算代码运行时间 返回对象类型proc_time ‵user time` 执行代码用时 system time CPU时间 elapsed time 实际用时 在多核或并行条件下实际用时可以短于执行代码用时 明确知道耗时较长的函数时使用 Rprof R代码要支持分析函数 summaryRprof可使结果易读 不要与system.time混用 0.02s记录一次执行函数 by.total 记录单个函数用时 by.self 记录函数执行时被调用函数用时 "],
["getting-and-cleaning-data.html", "Notes 4 Getting and Cleaning Data 4.1 概述 4.2 下载 4.3 读取本地文件 4.4 读取excle文件 4.5 读取XML文件 4.6 读取json文件 4.7 读取MySQL数据库 4.8 读取HDF5数据 4.9 读取网页数据 4.10 读取API 4.11 读取其他资源 4.12 数据截取与排序 4.13 数据总结 4.14 数据整理 4.15 数据操作data.table包 4.16 文本处理 4.17 日期处理", " Notes 4 Getting and Cleaning Data 4.1 概述 Raw data -&gt; Processing script -&gt; tidy data 前期需求 原始数据 干净数据 code book 详尽的处理步骤记录 原始数据要求 未经处理 未经修改 未经去除异常值 未经总结 干净数据 每个变量一列 同一变量不同样本不在一行 一种变量一个表 多张表要有一列可以相互链接 有表头 变量名要有意义 一个文件一张表 code book 变量信息 总结方式 实验设计 文本文件 包含研究设计与变量信息的章节 处理步骤记录 脚本文件 输入为原始数据 输出为处理过数据 脚本中无特定参数 4.2 下载 设定工作目录与数据存储目录 if (!file.exists(&quot;data&quot;)) { dir.create(&quot;data&quot;) } url下载与时间记录 fileUrl &lt;- &quot;yoururl&quot; download.file(fileUrl, destfile = &quot;./data/XXX.csv&quot;, method = &quot;curl&quot;) list.files(&quot;./data&quot;) dateDownloaded &lt;- date() 4.3 读取本地文件 read.table read.csv 默认sep=&quot;,&quot;, header=TRUE quote 设定引用 na.strings 设定缺失值字符 nrows 设定读取字段 skip 跳过开始行数 4.4 读取excle文件 xlsx包 library(xlsx) cameraData &lt;- read.xlsx(&quot;./data/cameras.xlsx&quot;,sheetIndex=1,header=TRUE) head(cameraData) # read.xlsx2更快不过选行读取时会不稳定 # 支持底层读取 如字体等 XLConnect包 library(XLConnect) wb &lt;- loadWorkbook(&quot;XLConnectExample1.xlsx&quot;, create = TRUE) createSheet(wb, name = &quot;chickSheet&quot;) writeWorksheet(wb, ChickWeight, sheet = &quot;chickSheet&quot;, startRow = 3, startCol = 4) saveWorkbook(wb) # 支持区域操作 生成报告 图片等 4.5 读取XML文件 网页常用格式 形式与内容分开 形式包括标签 元素 属性等 XML包 library(XML) fileUrl &lt;- &quot;http://www.w3schools.com/xml/simple.xml&quot; # 读取xml结构 doc &lt;- xmlTreeParse(fileUrl,useInternal=TRUE) # 提取节点 rootNode &lt;- xmlRoot(doc) # 提取根节点名 xmlName(rootNode) # 提取子节点名 names(rootNode) # 提取节点数值 xmlSApply(rootNode,xmlValue) XPath XML的一种查询语法 /node 顶级节点 //node 所有子节点 node(???) 带属性名的节点 node(??? =“bob”) 属性名为bob的节点 # 提取节点下属性名为name的数值 xpathSApply(rootNode,&quot;//name&quot;,xmlValue) 4.6 读取json文件 js对象符号 结构化 常作为API输出格式 jsonlite包 library(jsonlite) # 读取json文件 jsonData &lt;- fromJSON(&quot;https://api.github.com/users/jtleek/repos&quot;) # 列出文件名 names(jsonData) # 可嵌套截取 jsonData$owner$login # 可将R对象写成json文件 myjson &lt;- toJSON(iris, pretty=TRUE) 4.7 读取MySQL数据库 网络应用常见数据库软件 一行一记录 数据库表间有index向量 常见命令 指南 RMySQL包 library(RMySQL) # 读取数据库 ucscDb &lt;- dbConnect(MySQL(),user=&quot;genome&quot;, host=&quot;genome-mysql.cse.ucsc.edu&quot;) result &lt;- dbGetQuery(ucscDb,&quot;show databases;&quot;); # 断开链接 dbDisconnect(ucscDb); # 读取指定数据库 hg19 &lt;- dbConnect(MySQL(),user=&quot;genome&quot;, db=&quot;hg19&quot;, host=&quot;genome-mysql.cse.ucsc.edu&quot;) allTables &lt;- dbListTables(hg19) length(allTables) # mysql语句查询 dbGetQuery(hg19, &quot;select count(*) from affyU133Plus2&quot;) # 选择子集 query &lt;- dbSendQuery(hg19, &quot;select * from affyU133Plus2 where misMatches between 1 and 3&quot;) affyMis &lt;- fetch(query); quantile(affyMis$misMatches) 4.8 读取HDF5数据 分层分组读取大量数据的格式 rhdf5包 library(rhdf5) created = h5createFile(&quot;example.h5&quot;) created = h5createGroup(&quot;example.h5&quot;,&quot;foo&quot;) created = h5createGroup(&quot;example.h5&quot;,&quot;baa&quot;) created = h5createGroup(&quot;example.h5&quot;,&quot;foo/foobaa&quot;) h5ls(&quot;example.h5&quot;) A = matrix(1:10,nr=5,nc=2) h5write(A, &quot;example.h5&quot;,&quot;foo/A&quot;) B = array(seq(0.1,2.0,by=0.1),dim=c(5,2,2)) attr(B, &quot;scale&quot;) &lt;- &quot;liter&quot; h5write(B, &quot;example.h5&quot;,&quot;foo/foobaa/B&quot;) h5ls(&quot;example.h5&quot;) df = data.frame(1L:5L,seq(0,1,length.out=5), c(&quot;ab&quot;,&quot;cde&quot;,&quot;fghi&quot;,&quot;a&quot;,&quot;s&quot;), stringsAsFactors=FALSE) h5write(df, &quot;example.h5&quot;,&quot;df&quot;) h5ls(&quot;example.h5&quot;) readA = h5read(&quot;example.h5&quot;,&quot;foo/A&quot;) readB = h5read(&quot;example.h5&quot;,&quot;foo/foobaa/B&quot;) readdf= h5read(&quot;example.h5&quot;,&quot;df&quot;) 4.9 读取网页数据 网页抓取HTML数据 读完了一定关链接 httr包 con = url(&quot;http://scholar.google.com/citations?user=HI-I6C0AAAAJ&amp;hl=en&quot;) htmlCode = readLines(con) close(con) htmlCode library(XML) url &lt;- &quot;http://scholar.google.com/citations?user=HI-I6C0AAAAJ&amp;hl=en&quot; html &lt;- htmlTreeParse(url, useInternalNodes=T) xpathSApply(html, &quot;//title&quot;, xmlValue) library(httr) html2 = GET(url) content2 = content(html2,as=&quot;text&quot;) parsedHtml = htmlParse(content2,asText=TRUE) xpathSApply(parsedHtml, &quot;//title&quot;, xmlValue) GET(&quot;http://httpbin.org/basic-auth/user/passwd&quot;) GET(&quot;http://httpbin.org/basic-auth/user/passwd&quot;, authenticate(&quot;user&quot;,&quot;passwd&quot;)) google = handle(&quot;http://google.com&quot;) pg1 = GET(handle=google,path=&quot;/&quot;) pg2 = GET(handle=google,path=&quot;search&quot;) 4.10 读取API 通过接口授权后调用数据 httr包 myapp = oauth_app(&quot;twitter&quot;, key=&quot;yourConsumerKeyHere&quot;,secret=&quot;yourConsumerSecretHere&quot;) sig = sign_oauth1.0(myapp, token = &quot;yourTokenHere&quot;, token_secret = &quot;yourTokenSecretHere&quot;) homeTL = GET(&quot;https://api.twitter.com/1.1/statuses/home_timeline.json&quot;, sig) json1 = content(homeTL) json2 = jsonlite::fromJSON(toJSON(json1)) 4.11 读取其他资源 图片 jpeg readbitmap png EBImage (Bioconductor) GIS rdgal rgeos raster 声音 tuneR seewave 4.12 数据截取与排序 增加行直接$ seq产生序列 通过[按行 列或条件截取 which返回行号 排序向量用sort 排序数据框(多向量)用order plyl包排序 library(plyr) arrange(X,var1) arrange(X,desc(var1)) 4.13 数据总结 head tail查看数据 summary str总结数据 quantile 按分位数总结向量 table 按向量元素频数总结 sum(is.na(data)) any(is.na(data)) all(data$x &gt; 0) 异常值总结 colSums(is.na(data)) 行列求和 table(data$x %in% c(&quot;21212&quot;))特定数值计数总结 xtabs ftable 创建列联表 print(object.size(fakeData),units=&quot;Mb&quot;) 现实数据大小 cut 通过设置breaks产生分类变量 Hmisc包 library(Hmisc) data$zipGroups = cut2(data$zipCode,g=4) table(data$zipGroups) library(plyr) # mutate进行数据替换或生成 data2 = mutate(data,zipGroups=cut2(zipCode,g=4)) table(data2$zipGroups) 4.14 数据整理 每一列一个变量 每一行一个样本 每个文件存储一类样本 melt进行数据融合 reshape2包 dcast分组汇总数据框 acast分组汇总向量数组 arrange指定变量名排序 merge按照指定向量合并数据 plyr包的join函数也可实现合并 4.15 数据操作data.table包 基本兼容data.frame 速度更快 通过key可指定因子变量并快速提取分组的行 可在第二个参数是R表达式 DT[,list(mean(x),sum(z))] DT[,table(y)] 可用:生成新变量 进行简单计算 DT[,w:=z^2] DT[,m:= {tmp &lt;- (x+z); log2(tmp+5)}] 进行数据条件截取 DT[,a:=x&gt;0] DT[,b:= mean(x+w),by=a] 进行计数 DT &lt;- data.table(x=sample(letters[1:3], 1E5, TRUE)) DT[, .N, by=x] 4.16 文本处理 处理大小写tolower toupper 处理变量名strsplit firstElement &lt;- function(x){x[1]} sapply(splitNames,firstElement) 字符替换sub gsub 寻找变量grep(返回行号) grepl(返回逻辑值) stringr包 stringr paste0 不带空格 str_trim 去除空格 命名原则 变量名小写 描述性 无重复 变量名不要符号分割 Names of variables should be 正则表达式 文字处理格式 ^ 匹配开头 $ 匹配结尾 [] 匹配大小写 ^在开头表示非 . 匹配任意字符 | 匹配或 () 匹配与 ? 匹配可选择 * 匹配任意 + 匹配至少一个 {} 匹配其中最小最大 一个值表示精确匹配 m,表示至少m次匹配 \\1 匹配前面指代 4.17 日期处理 formate处理日期格式 %d 日 %a 周缩写 %A 周 %m 月 %b 月缩写 %B 月全名 %y 2位年 %Y 4位年 weekdays 显示星期 months 显示月份 julian 显示70年以来的日期 lubridate包 ymd mdy dmy ymd_hms Sys.timezone "],
["exploratory-data-analysis.html", "Notes 5 Exploratory Data Analysis 5.1 探索绘图原则 5.2 探索性绘图 5.3 R绘图系统 5.4 分层聚类 5.5 k-means聚类 5.6 维度还原", " Notes 5 Exploratory Data Analysis 5.1 探索绘图原则 表示可比的对比 表示因果 解释 机制 系统结构 表示多元变量（超过2） 证据整合 目的驱动非工具驱动 证据描述要标注限定恰当 内容为王 5.2 探索性绘图 个人理解用 不用过分关注细节 基于问题或假设出发 5.3 R绘图系统 5.3.1 基础包 艺术家绘画模式 graphics 包括基础包的绘图函数如plot, hist, boxplot grDevices 包括执行调用绘图设备函数如X11, PDF, PostScript, PNG 叠加函数 高度自由度 初始化新图 然后标注 以下命令熟记 pch: the plotting symbol (default is open circle) lty: the line type (default is solid line), can be dashed, dotted, etc. lwd: the line width, specified as an integer multiple col: the plotting color, specified as a number, string, or hex code; the colors() function gives you a vector of colors by name xlab: character string for the x-axis label ylab: character string for the y-axis label par():查找做图的画布参数 具体如下 las: the orientation of the axis labels on the plot bg: the background color mar: the margin size oma: the outer margin size (default is 0 for all sides) mfrow: number of plots per row, column (plots are filled row-wise) mfcol: number of plots per row, column (plots are filled column-wise) plot: make a scatterplot, or other type of plot depending on the class of the object being plotted lines: add lines to a plot, given a vector x values and a corresponding vector of y values (or a 2-column matrix); this function just connects the dots points: add points to a plot text: add text labels to a plot using specified x, y coordinates title: add annotations to x, y axis labels, title, subtitle, outer margin mtext: add arbitrary text to the margins (inner or outer) of the plot axis: adding axis ticks/labels 图形设备 图像一定要有设备 屏幕设备 Mac quartz() windows windows() Unix/linux x11() 先调用后用dev.off()关闭设备 矢量图设备 保真放大 元素过多体积庞大 pdf() svg() winmetafile() postscript() 位图设备 放大失真 基于像素 png() jpeg() tiff() bmp() 当前设备dev.cur() 设置设备dev.set(&lt;integer&gt;) 设备转移dev.copy dev.copy2pdf 5.3.2 lattice 一站式解决 lattice 包括框架图函数如xyplot, bwplot, levelplot grid 包括独立于基础绘图系统的网格绘图系统 一个函数解决问题 默认自定义空间少 返回trellis类型对象 可单独存储 界面调整使用panel选项 以下为常见函数 xyplot: this is the main function for creating scatterplots bwplot: box-and-whiskers plots (“boxplots”) histogram: histograms stripplot: like a boxplot but with actual points dotplot: plot dots on “violin strings” splom: scatterplot matrix; like pairs in base plotting system levelplot, contourplot: for plotting “image” data 基本格式 xyplot(y ~ x | f * g, data) 可同时展示分组信息及交互作用 5.3.3 ggplot2 基于图形语法理念 图形属性映射数据问题 自动处理界面 允许后期添加 结合base与lattice 默认友好 基础绘图qplot() ggplot() 通过叠加元素出图 细节调整xlab(), ylab(), labs(), ggtitle() 主题调整theme() 做图需求 数据框 data.frame 属性映射 asethetic mappling 几何对象 geoms 条件 facets 统计转换 stats 范围量表 scales 坐标轴系统 coordinate system 5.3.4 数学绘图 Tex语法 使用expression() ?plotmath 5.3.5 色彩管理 colorRamp 返回01间数值 表示颜色过度 colorRampPalette 返回8位颜色代码调色盘 colors 返回可用颜色 RColorBrewer包 含有预先配色信息 序列 无序 两级 rgb产生三原色颜色 alpha 控制透明度 绘图时用col调用调色盘颜色 pal &lt;- colorRamp(c(&quot;red&quot;, &quot;blue&quot;)) pal(0) ## [,1] [,2] [,3] ## [1,] 255 0 0 pal(1) ## [,1] [,2] [,3] ## [1,] 0 0 255 pal(0.5) ## [,1] [,2] [,3] ## [1,] 127.5 0 127.5 ##### pal &lt;- colorRampPalette(c(&quot;red&quot;, &quot;yellow&quot;)) pal(2) ## [1] &quot;#FF0000&quot; &quot;#FFFF00&quot; pal(10) ## [1] &quot;#FF0000&quot; &quot;#FF1C00&quot; &quot;#FF3800&quot; &quot;#FF5500&quot; &quot;#FF7100&quot; &quot;#FF8D00&quot; &quot;#FFAA00&quot; ## [8] &quot;#FFC600&quot; &quot;#FFE200&quot; &quot;#FFFF00&quot; ##### library(RColorBrewer) cols &lt;- brewer.pal(3, &quot;BuGn&quot;) 5.4 分层聚类 找到最近的 聚到一起 找下个最近的 给出距离范围与距离计算方法 欧氏距离 多维空间点距 开平方 manhattan距离 出租车距离 绝对值 给出变量间或样本间的关系 图形可能不稳定 多少样本多少类 结果是确定的 选定cut点并不明显 应该首先用来探索 5.5 k-means聚类 固定聚类数 给出聚类中心 寻找最近的点 循环 需要聚类数与聚类距离范围 需要大量聚类 通过眼睛 交叉检验 k的经验数值\\(\\sqrt{n/2}\\) 或者根据解释的变量变化多少来选取 结果不确定 根据聚类数与迭代次数而变化 5.6 维度还原 找到最不相关的数来解释整体方差（统计）在这些数中选取个数最少的来解释原始数据（压缩） 不一定是真实向量的叠加 SVD是PCA的一种解法 UDV三个向量 其中U表示行变化模式 D表示方差 V表示列变换模式 这样有助于解释主成分变化 标准化与否影响结果 计算量大 类似探索分析还有因子分析 独立成分分析 潜在语义分析 impute包可补充缺失值 "],
["reproducible-research.html", "Notes 6 Reproducible Research 6.1 Replication 6.2 Reproducible 6.3 研究流程 6.4 数据分析步骤 6.5 数据分析文件结构", " Notes 6 Reproducible Research 6.1 Replication 科学研究的的终极标准是研究证据可独立发现与验证 并非所有结果都可以重复 6.2 Reproducible 可重复的数据分析过程与代码 数据维度增高 现有数据可被整合入更大的数据集 计算机条件允许 6.3 研究流程 流程图 6.4 数据分析步骤 定义问题 背后要有科学假设或问题 从大到小 具体定义 定义理想数据 描述性的 &lt;- 总体数据 探索性的 &lt;- 有属性测量的样本数据 推断性的 &lt;- 合适的总体 随机采样 预测性的 &lt;- 来自同一总体 有训练集与测试集的样本 因果性的 &lt;- 随机性研究 机械性的 &lt;- 系统中所有组成部分的数据 决定可获取数据 网络免费数据 购买数据 注意使用条款 数据不存在 自己创造 &lt;- 实验 获取数据 原始数据 引用来源 网络数据注明数据来源URL与获取时间 整理数据 原始数据需要整理 如果事先处理过要搞清楚如何处理的 了解数据来源 需要重新格式化 采样 &lt;- 记录步骤 判断数据是否合适 不合适重新获取 探索性数据分析 描述性总结数据 检查缺失值 绘制探索性图 尝试探索性分析 例如聚类 统计预测/建模 基于探索性分析 根据问题确定方法 数据转换要解释 测定的不确定性要考虑 解释结果 描述 相关 推断 预测 质疑结果 问题 数据源 处理过程 分析 结论 整合写出结果 从问题角度出发 形成一个故事 不要包含分析过程除非用来说明问题 消除质疑 以故事而不是时间顺序描述 图片要漂亮 写出可重复的R代码 Rmarkdown文件 6.5 数据分析文件结构 Data Raw data 来自网络在Readme里注明url 描述 日期 Processed data 命名体现处理过程 Readme里注明处理过程 Figures Exploratory figures 不必考虑装饰 Final figures 只考虑装饰 R code Raw scripts 不必过分注释 版本控制 不一定用得上 Final scripts 注释清晰 包括处理细节 只包括文章需要费分析 R Markdown files (optional) Text Readme files 按步骤记录清晰 Text of analysis 包括前言 方法 结果 结论 讲故事 有引用 "],
["-knitr.html", "Notes 7 文本化统计编程-Knitr", " Notes 7 文本化统计编程-Knitr markdown是轻量化结构语言 R markdown 是轻量化统计结构语言 文本+代码块 逻辑清晰 文本语言可用latex markdown 代码块可用R 不用保存输出 可缓存结果 cacher包 "],
["section-8.html", "Notes 8 结果通讯 8.1 检查列表 8.2 基于证据的数据分析", " Notes 8 结果通讯 研究论文的信息层级 题目/作者名单 摘要 主体/结果 支持材料/细节 代码/数据 邮件汇报的信息层级 题目最好一行一句 描述问题 如何实验 总结发现 简明扼要 如果有问题 写成yes/no形式 附件齐全严谨 8.1 检查列表 数据选取得当 问题简单专一 队友靠谱 兴趣驱动 不要手动处理数据 全部交给计算机 少用交互界面 用命令行界面并记录历史 使用版本控制 处理降速而冷静 记录软件操作环境 sessionInfo() 不保存结果保证数据可重复 使用随机数要说明种子 原始数据-处理数据-分析-报告 考虑从哪一步开始数据重复性变差 8.2 基于证据的数据分析 可重复性研究不保证结果是对的 发表后研究存在动因 应关注数据生成前的过程 设定基于证据研究的路线图 减少研究人员的自由度 提出区域研究范式 "],
["statistical-inference.html", "Notes 9 Statistical Inference 9.1 导论 9.2 概率 9.3 期望 9.4 方差 9.5 独立性 9.6 条件概率 9.7 贝叶斯定理 9.8 常见分布 9.9 渐进 9.10 T 置信区间 9.11 似然函数 9.12 贝叶斯推断 9.13 两独立样本t检验 9.14 假设检验 9.15 P 值 9.16 功效 9.17 多重比较 9.18 重采样推断", " Notes 9 Statistical Inference 9.1 导论 定义 用需要考虑不确定度的含噪音的统计学数据推断事实 工具 随机化 随机采样 采样模型 假设检验 置信区间 概率模型 实验设计 bootstraping 排列交换随机 类型 频率派 使用概率的频率解释来控制错误率 贝叶斯派 给定概率与数据概率哪个靠谱 9.2 概率 术语 样本空间 Ω 事件 样本空间子集 E 单独事件 ω 空事件 ∅ \\(ω∈E\\) ω发生E发生 \\(ω∉E\\) ω发生E不发生 \\(E⊂F\\) E发生则F发生 \\(E∩F\\) EF一起发生 \\(E∪F\\) EF中至少一个发生 \\(E∩F=∅\\) EF互斥 \\(E^c\\) 或 \\(\\bar E\\) E不发生 概率 对事件 \\(E\\subset \\Omega\\), \\(0 \\leq P(E) \\leq 1\\) \\(P(\\Omega) = 1\\) 如果 \\(E_1\\) 与 \\(E_2\\) 互斥 有\\(P(E_1 \\cup E_2) = P(E_1) + P(E_2)\\). 概率无限可加性 \\(P(\\cup_{i=1}^n A_i) = \\sum_{i=1}^n P(A_i)\\) \\(P(\\emptyset) = 0\\) \\(P(E) = 1 - P(E^c)\\) \\(P(A \\cup B) = P(A) + P(B) - P(A \\cap B)\\) 如果 \\(A \\subset B\\) 则 \\(P(A) \\leq P(B)\\) \\(P\\left(A \\cup B\\right) = 1 - P(A^c \\cap B^c)\\) \\(P(A \\cap B^c) = P(A) - P(A \\cap B)\\) \\(P(\\cup_{i=1}^n E_i) \\leq \\sum_{i=1}^n P(E_i)\\) \\(P(\\cup_{i=1}^n E_i) \\geq \\max_i P(E_i)\\) 随机变量 实验的数值输出 离散随机变量取可数的概率 \\(P(X = k)\\) 连续随机变量取连续区间子集概率 \\(P(X \\in A)\\) 概率质量函数（PMF）&lt;- 离散随机变量 对于所有 \\(x\\) \\(p(x) \\geq 0\\) \\(\\sum_{x} p(x) = 1\\) 概率密度函数（PDF）&lt;- 连续随机变量 对于所有 \\(x\\) \\(f(x) \\geq 0\\) \\(f(x)\\) 下面积为1 累计概率函数（CDF） 定义 \\(F(x) = P(X \\leq x)\\) 生存函数 \\(S(x) = P(X &gt; x)\\) \\(S(x) = 1 - F(x)\\) 对于连续函数 CDF是PDF的积分 分位数 \\(\\alpha^{th}\\) \\(F(x_\\alpha) = \\alpha\\) \\(50^{th}\\) 分位数是中位数 9.3 期望 离散随机变量均值 \\(E[X] = \\sum_x xp(x)\\) \\(E[X]\\) 代表质量与位置的中心 \\(\\{x, p(x)\\}\\) 连续随机变量均值 \\(E[X] = \\mbox{the area under the function}~~~ t f(t)\\) 期望值是线性可加的 如果 \\(a\\) 与 \\(b\\) 不随机 \\(X\\) 与 \\(Y\\) 是随机变量 \\(E[aX + b] = a E[X] + b\\) \\(E[X + Y] = E[X] + E[Y]\\) 样本均值是总体均值\\(\\mu\\)的无偏估计的证明 \\[ \\begin{eqnarray*} E\\left[ \\frac{1}{n}\\sum_{i=1}^n X_i\\right] &amp; = &amp; \\frac{1}{n} E\\left[\\sum_{i=1}^n X_i\\right] \\\\ &amp; = &amp; \\frac{1}{n} \\sum_{i=1}^n E\\left[X_i\\right] \\\\ &amp; = &amp; \\frac{1}{n} \\sum_{i=1}^n \\mu = \\mu. \\end{eqnarray*} \\] 9.4 方差 描述随机变量的离散情况 如果 \\(X\\) 是均值 \\(\\mu\\) 的随机变量 其方差为\\(Var(X) = E[(X - \\mu)^2]\\) 离开均值距离期望的平方 计算公式 \\(Var(X) = E[X^2] - E[X]^2\\) 如果 \\(a\\) 是常数有 \\(Var(aX) = a^2 Var(X)\\) 方差的开方是标准差 单位与 \\(X\\) 一致 车比雪夫不等式（Chebyshev’s inequality）边界极为保守 \\[ P(|X - \\mu| \\geq k\\sigma) \\leq \\frac{1}{k^2} \\] 9.5 独立性 独立事件 两事件 \\(A\\) 与 \\(B\\) 在 \\(P(A \\cap B) = P(A)P(B)\\) 下独立 在 \\(P([X \\in A] \\cap [Y \\in B]) = P(X\\in A)P(Y\\in B)\\) 下两随机变量 \\(X\\) 与 \\(Y\\) 独立 对于一组随机独立变量\\(X_1, X_2, \\ldots, X_n\\)有 \\(f(x_1,\\ldots, x_n) = \\prod_{i=1}^n f_i(x_i)\\) iid随机变量（independent and identically distributed） 来自同一分布相互独立的随机变量 协方差（covariance） \\(Cov(X, Y) = E[(X - \\mu_x)(Y - \\mu_y)] = E[X Y] - E[X]E[Y]\\) \\(Cov(X, Y) = Cov(Y, X)\\) \\(Cov(X, Y)\\) 可以有正负 \\(|Cov(X, Y)| \\leq \\sqrt{Var(X) Var(y)}\\) 相关性（correlation） \\(X\\) 与 \\(Y\\) 的相关性 \\(Cor(X, Y) = Cov(X, Y) / \\sqrt{Var(X) Var(y)}\\) \\(-1 \\leq Cor(X, Y) \\leq 1\\) 只有对常数 \\(a\\) 与 \\(b\\)满足 \\(X = a + bY\\) 时\\(Cor(X, Y) = \\pm 1\\) \\(Cor(X, Y)\\) 无单位 \\(Cor(X, Y) = 0\\) 时 \\(X\\) 与 \\(Y\\) 不相关 \\(Cor(X,Y)\\) 越接近1 \\(X\\) 与 \\(Y\\) 越正相关 反之接近-1 负相关 \\(\\{X_i\\}_{i=1}^n\\) 是一组随机变量 当 \\(\\{X_i\\}\\) 不相关时 \\(Var\\left(\\sum_{i=1}^n a_i X_i + b\\right) = \\sum_{i=1}^n a_i^2 Var(X_i)\\) 如果一组随机变量\\(\\{X_i\\}\\)不相关 方差的和等于和的方差 非标准差 样本均值方差的推导 \\[ \\begin{eqnarray*} Var(\\bar X) &amp; = &amp; Var \\left( \\frac{1}{n}\\sum_{i=1}^n X_i \\right)\\\\ \\\\ &amp; = &amp; \\frac{1}{n^2} Var\\left(\\sum_{i=1}^n X_i \\right)\\\\ \\\\ &amp; = &amp; \\frac{1}{n^2} \\sum_{i=1}^n Var(X_i) \\\\ \\\\ &amp; = &amp; \\frac{1}{n^2} \\times n\\sigma^2 \\\\ \\\\ &amp; = &amp; \\frac{\\sigma^2}{n} \\end{eqnarray*} \\] 当 \\(X_i\\) 独立且方差为 \\(Var(\\bar X) = \\frac{\\sigma^2}{n}\\) \\(\\sigma/\\sqrt{n}\\) 为样本均值的标准误 样本均值的标准误就是样本均值分布的标准差 \\(\\sigma\\) 是一次观察分布的标准差 样本均值要比一次观察变化小 因此除以\\(\\sqrt{n}\\) 样本方差 \\(S^2 = \\frac{\\sum_{i=1}^n (X_i - \\bar X)^2}{n-1}\\) 总体方差 \\(\\sigma^2\\)的估计 计算 \\(\\sum_{i=1}^n (X_i - \\bar X)^2 = \\sum_{i=1}^n X_i^2 - n \\bar X^2\\) 均值偏差平方的均值 样本方差是总体方差的无偏估计 \\[ \\begin{eqnarray*} E\\left[\\sum_{i=1}^n (X_i - \\bar X)^2\\right] &amp; = &amp; \\sum_{i=1}^n E\\left[X_i^2\\right] - n E\\left[\\bar X^2\\right] \\\\ \\\\ &amp; = &amp; \\sum_{i=1}^n \\left\\{Var(X_i) + \\mu^2\\right\\} - n \\left\\{Var(\\bar X) + \\mu^2\\right\\} \\\\ \\\\ &amp; = &amp; \\sum_{i=1}^n \\left\\{\\sigma^2 + \\mu^2\\right\\} - n \\left\\{\\sigma^2 / n + \\mu^2\\right\\} \\\\ \\\\ &amp; = &amp; n \\sigma^2 + n \\mu ^ 2 - \\sigma^2 - n \\mu^2 \\\\ \\\\ &amp; = &amp; (n - 1) \\sigma^2 \\end{eqnarray*} \\] 澄清 假定 \\(X_i\\) 是 iid 均值 \\(\\mu\\) 方差 \\(\\sigma^2\\) \\(S^2\\) 估计 \\(\\sigma^2\\) \\(S^2\\) 的计算涉及除 \\(n-1\\) \\(S / \\sqrt{n}\\) 估计 \\(\\sigma / \\sqrt{n}\\) 是均值的标准误 9.6 条件概率 \\(B\\) 为一个事件 有 \\(P(B) &gt; 0\\) \\(B\\) 出现条件下 \\(A\\) 的条件概率为 \\(P(A ~|~ B) = \\frac{P(A \\cap B)}{P(B)}\\) 如果 \\(A\\) 与 \\(B\\) 独立 有 \\(P(A ~|~ B) = \\frac{P(A) P(B)}{P(B)} = P(A)\\) 9.7 贝叶斯定理 \\[ P(B ~|~ A) = \\frac{P(A ~|~ B) P(B)}{P(A ~|~ B) P(B) + P(A ~|~ B^c)P(B^c)}. \\] 2*2 列联表 - 诊断测试 示意图 9.8 常见分布 贝努力分布 二元输出变量 数值为0或1 概率\\(p\\) 与 \\(1-p\\) \\(X\\)的PMF是\\(P(X = x) = p^x (1 - p)^{1 - x}\\) 均值 \\(p\\) 方差 \\(p(1 - p)\\) 如果有iid的贝努力观察\\(x_1,\\ldots, x_n\\) 似然函数 \\(\\prod_{i=1}^n p^{x_i} (1 - p)^{1 - x_i} = p^{\\sum x_i} (1 - p)^{n - \\sum x_i}\\) 似然函数依赖\\(x_i\\)的和 \\(\\sum_i x_i / n\\) 包含了所有 \\(p\\) 的可能性 最大化似然函数可以得到 \\(p\\) 的估计 二项分布 PMF \\[ P(X = x) = \\left( \\begin{array}{c} n \\\\ x \\end{array} \\right) p^x(1 - p)^{n-x} \\] 对于 \\(x=0,\\ldots,n\\) 正态分布 PDF \\((2\\pi \\sigma^2)^{-1/2}e^{-(x - \\mu)^2/2\\sigma^2}\\) \\(X\\) 为均值 \\(E[X] = \\mu\\) 方差 \\(Var(X) = \\sigma^2\\) 的iid随机变量 写作\\(X\\sim \\mbox{N}(\\mu, \\sigma^2)\\) 均值 \\(\\mu = 0\\) 方差 \\(\\sigma = 1\\) 是标准正态分布 标准正态函数写作 \\(\\phi\\) 标准正态随机变量用 \\(Z\\) 表示 如果 \\(X \\sim \\mbox{N}(\\mu,\\sigma^2)\\) 并且 \\(Z = \\frac{X -\\mu}{\\sigma}\\) 是标准正态函数 如果 \\(Z\\) 是标准正态函数 \\(X = \\mu + \\sigma Z \\sim \\mbox{N}(\\mu, \\sigma^2)\\) 非标准正态密度函数 \\(\\phi\\{(x - \\mu) / \\sigma\\}/\\sigma\\) 正态似然函数对方差的估计是有偏的 正态的和是正态 样本均值正态 正态的平方是卡方 泊松分布 PMF \\(P(X = x; \\lambda) = \\frac{\\lambda^x e^{-\\lambda}}{x!}\\) 均值方差均为 \\(\\lambda\\) 可看做很短时间间隔中发生事件的概率 模拟速率 其中\\(\\lambda * h\\)小于1 则各时间段独立 \\(X \\sim Poisson(\\lambda t)\\) \\(\\lambda = E[X / t]\\)是速率 \\(t\\) 是总时间 \\(n\\) 大 \\(p\\) 小是对二项分布的模拟 \\(X \\sim \\mbox{Binomial}(n, p)\\), \\(\\lambda = n p\\) 9.9 渐进 样本接近无穷大时统计量的行为 频率派的基石 大数理论（LLN） 样本数量越多 均值接近期望 中心极限理论 (CLT) iid 变量均值的分布标准化后随样本数增加接近标准正态分布 \\[ \\frac{\\bar X_n - \\mu}{\\sigma / \\sqrt{n}} = \\frac{\\mbox{Estimate} - \\mbox{Mean of estimate}}{\\mbox{Std. Err. of estimate}} \\] 可根据变量分布来 知道均值 方差 计算出样本均值标准误 就可以根据CLT计算逼近的统计量 置信区间 根据CLT随机区间\\(\\bar X_n \\pm z_{1-\\alpha/2}\\sigma / \\sqrt{n}\\) 包括 \\(\\mu\\) 的概率逼近于 100\\((1-\\alpha)\\)% \\(z_{1-\\alpha/2}\\)为标准正态分布\\(1-\\alpha/2\\)的分位数 \\(100(1 - \\alpha)\\)% 为置信区间 \\(\\sigma\\) 可用样本估计 \\(s\\) 来近似 估计是基于分布假设的 如果分布有解析解 则置信区间可以更准确的得到估计 先生成不依赖参数的统计量 根据统计量的概率分布计算参数的边界 9.10 T 置信区间 卡方分布 假定 \\(S^2\\) 是来自\\(n\\)个 iid \\(N(\\mu,\\sigma^2)\\) 数据样本的方差 有\\(\\frac{(n - 1) S^2}{\\sigma^2} \\sim \\chi^2_{n-1}\\) 符合自由度\\(n-1\\)的卡方分布 不对称分布 均值是自由度 方差是两倍的自由度 方差的置信区间 \\[ \\begin{eqnarray*} 1 - \\alpha &amp; = &amp; P \\left( \\chi^2_{n-1, \\alpha/2} \\leq \\frac{(n - 1) S^2}{\\sigma^2} \\leq \\chi^2_{n-1,1 - \\alpha/2} \\right) \\\\ \\\\ &amp; = &amp; P\\left(\\frac{(n-1)S^2}{\\chi^2_{n-1,1-\\alpha/2}} \\leq \\sigma^2 \\leq \\frac{(n-1)S^2}{\\chi^2_{n-1,\\alpha/2}} \\right) \\\\ \\end{eqnarray*} \\] \\(\\left[\\frac{(n-1)S^2}{\\chi^2_{n-1,1-\\alpha/2}}, \\frac{(n-1)S^2}{\\chi^2_{n-1,\\alpha/2}}\\right]\\) 是 \\(\\sigma^2\\) 的 \\(100(1-\\alpha)\\%\\) 置信区间 依赖正态性假设 开方后得到 \\(\\sigma\\) 的置信区间 Gosset的 t 分布 比正态分布尾厚 考虑自由度 自由度大时接近正态分布 \\(\\frac{Z}{\\sqrt{\\frac{\\chi^2}{df}}}\\) 假定 \\((X_1,\\ldots,X_n)\\) 是 iid \\(N(\\mu,\\sigma^2)\\) 有 \\(\\frac{\\bar X - \\mu}{\\sigma / \\sqrt{n}}\\) 是标准正态分布 \\(\\sqrt{\\frac{(n - 1) S^2}{\\sigma^2 (n - 1)}} = S / \\sigma\\) 是卡方除以自由度的开方 有 \\[ \\frac{\\frac{\\bar X - \\mu}{\\sigma /\\sqrt{n}}}{S/\\sigma} = \\frac{\\bar X - \\mu}{S/\\sqrt{n}} \\] 服从自由度\\(n-1\\)的\\(t\\)分布 均值的置信区间 \\[ \\begin{eqnarray*} &amp; &amp; 1 - \\alpha \\\\ &amp; = &amp; P\\left(-t_{n-1,1-\\alpha/2} \\leq \\frac{\\bar X - \\mu}{S/\\sqrt{n}} \\leq t_{n-1,1-\\alpha/2}\\right) \\\\ \\\\ &amp; = &amp; P\\left(\\bar X - t_{n-1,1-\\alpha/2} S / \\sqrt{n} \\leq \\mu \\leq \\bar X + t_{n-1,1-\\alpha/2}S /\\sqrt{n}\\right) \\end{eqnarray*} \\] \\(t_{df,\\alpha}\\) 是t分布的 \\(\\alpha^{th}\\) 分位数 自由度 \\(df\\) t检验不适合有偏分布 置信区间中心也不在均值上 9.11 似然函数 一组数据的似然函数是数据固定下参数的联合概率密度函数 似然函数可用来估计参数 是参数的函数 似然函数比估计两个可能参数值的可能性 给定模型与数据 似然函数包含所有参数可能性 样本独立时 参数的似然函数是各独立样本似然函数的乘积 参数使似然函数概率取最大值时真实的可能性更大 更支持这组数据 这个估计是最大似然估计（MLE） 9.12 贝叶斯推断 \\(\\mbox{Posterior} \\propto \\mbox{Likelihood} \\times \\mbox{Prior}\\) 先验beta分布 01之间 依赖 \\(\\alpha\\) \\(\\beta\\) 的概率密度函数 \\[ \\frac{\\Gamma(\\alpha + \\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)} p ^ {\\alpha - 1} (1 - p) ^ {\\beta - 1} ~~~~\\mbox{for} ~~ 0 \\leq p \\leq 1 \\] 均值 \\(\\alpha / (\\alpha + \\beta)\\) 方差 \\(\\frac{\\alpha \\beta}{(\\alpha + \\beta)^2 (\\alpha + \\beta + 1)}\\) \\(\\alpha = \\beta = 1\\) 为均匀分布 后验beta分布 参数\\(\\tilde \\alpha = x + \\alpha\\) \\(\\tilde \\beta = n - x + \\beta\\) 的beta分布 \\[ \\begin{align} \\mbox{Posterior} &amp;\\propto p^x(1 - p)^{n-x} \\times p^{\\alpha -1} (1 - p)^{\\beta - 1} \\\\ &amp; = p^{x + \\alpha - 1} (1 - p)^{n - x + \\beta - 1} \\end{align} \\] 后验均值 \\[ \\begin{align} E[p ~|~ X] &amp; = \\frac{\\tilde \\alpha}{\\tilde \\alpha + \\tilde \\beta}\\\\ \\\\ &amp; = \\frac{x + \\alpha}{x + \\alpha + n - x + \\beta}\\\\ \\\\ &amp; = \\frac{x + \\alpha}{n + \\alpha + \\beta} \\\\ \\\\ &amp; = \\frac{x}{n} \\times \\frac{n}{n + \\alpha + \\beta} + \\frac{\\alpha}{\\alpha + \\beta} \\times \\frac{\\alpha + \\beta}{n + \\alpha + \\beta} \\\\ \\\\ &amp; = \\mbox{MLE} \\times \\pi + \\mbox{Prior Mean} \\times (1 - \\pi) \\end{align} \\] 后验均值是先验均值与最大似然估计的混合 当 \\(n\\) 变大 \\(\\pi\\) 接近 \\(1\\) 先验作用小 当 \\(n\\) 很小 先验作用大 当数据量够大时 先验概率作用就很小了 当先验概率足够稳定 数据就作用不大了 信任区间 \\(95\\%\\) 信任区间 \\([a, b]\\) 会满足\\(P(p \\in [a, b] ~|~ x) = .95\\) 最高后验密度 (HPD) 区间 9.13 两独立样本t检验 \\(X_1,\\ldots,X_{n_x}\\) 为 iid \\(N(\\mu_x,\\sigma^2)\\) \\(Y_1,\\ldots,Y_{n_y}\\) 为 iid \\(N(\\mu_y, \\sigma^2)\\) \\(\\bar X\\), \\(\\bar Y\\), \\(S_x\\), \\(S_y\\) 为均值与标准差 根据均值与方差的线性组合 有 \\(\\bar Y - \\bar X\\) 也是正态 均值 \\(\\mu_y - \\mu_x\\) 方差 \\(\\sigma^2 (\\frac{1}{n_x} + \\frac{1}{n_y})\\) 混合方差为 \\(S_p^2 = \\{(n_x - 1) S_x^2 + (n_y - 1) S_y^2\\}/(n_x + n_y - 2)\\) 为\\(\\sigma^2\\)的良好估计 该估计为无偏估计 \\[ \\begin{eqnarray*} E[S_p^2] &amp; = &amp; \\frac{(n_x - 1) E[S_x^2] + (n_y - 1) E[S_y^2]}{n_x + n_y - 2}\\\\ &amp; = &amp; \\frac{(n_x - 1)\\sigma^2 + (n_y - 1)\\sigma^2}{n_x + n_y - 2} \\end{eqnarray*} \\] 该估计独立于 \\(\\bar Y - \\bar X\\) 因为方差独立于均值 两个独立的卡方变量之和是自由度之和的卡方值 \\[ \\begin{eqnarray*} (n_x + n_y - 2) S_p^2 / \\sigma^2 &amp; = &amp; (n_x - 1)S_x^2 /\\sigma^2 + (n_y - 1)S_y^2/\\sigma^2 \\\\ \\\\ &amp; = &amp; \\chi^2_{n_x - 1} + \\chi^2_{n_y-1} \\\\ \\\\ &amp; = &amp; \\chi^2_{n_x + n_y - 2} \\end{eqnarray*} \\] 构建统计量 \\[ \\frac{\\frac{\\bar Y - \\bar X - (\\mu_y - \\mu_x)}{\\sigma \\left(\\frac{1}{n_x} + \\frac{1}{n_y}\\right)^{1/2}}}{\\sqrt{\\frac{(n_x + n_y - 2) S_p^2}{(n_x + n_y - 2)\\sigma^2}}} = \\frac{\\bar Y - \\bar X - (\\mu_y - \\mu_x)}{S_p \\left(\\frac{1}{n_x} + \\frac{1}{n_y}\\right)^{1/2}} \\] 该统计量为符合自由度 \\(n_x + n_y - 2\\) 的 \\(t\\) 分布 置信区间 \\[ \\bar Y - \\bar X \\pm t_{n_x + n_y - 2, 1 - \\alpha/2}S_p\\left(\\frac{1}{n_x} + \\frac{1}{n_y}\\right)^{1/2} \\] 方差不等 \\[ \\bar Y - \\bar X \\sim N\\left(\\mu_y - \\mu_x, \\frac{s_x^2}{n_x} + \\frac{s_y^2}{n_y}\\right) \\] 统计量 \\[ \\frac{\\bar Y - \\bar X - (\\mu_y - \\mu_x)}{\\left(\\frac{s_x^2}{n_x} + \\frac{s_y^2}{n_y}\\right)^{1/2}} \\] 近似于自由度 \\[ \\frac{\\left(S_x^2 / n_x + S_y^2/n_y\\right)^2} {\\left(\\frac{S_x^2}{n_x}\\right)^2 / (n_x - 1) + \\left(\\frac{S_y^2}{n_y}\\right)^2 / (n_y - 1)} \\] 的\\(t\\)分布 9.14 假设检验 使用数据做决定 空假设 \\(H_0\\) 无变化 备择假设 \\(H_a\\) 或大 或小 或不等 真值表 Truth Decide Result \\(H_0\\) \\(H_0\\) Correctly accept null \\(H_0\\) \\(H_a\\) Type I error \\(H_a\\) \\(H_a\\) Correctly reject null \\(H_a\\) \\(H_0\\) Type II error Z检验 Z检验 \\(H_0:\\mu = \\mu_0\\) 与 \\(H_1: \\mu &lt; \\mu_0\\) \\(H_2: \\mu \\neq \\mu_0\\) \\(H_3: \\mu &gt; \\mu_0\\) 检验统计量 \\(TS = \\frac{\\bar{X} - \\mu_0}{S / \\sqrt{n}}\\) 拒绝空假设条件 \\(TS \\leq -Z_{1 - \\alpha}\\) \\(|TS| \\geq Z_{1 - \\alpha / 2}\\) \\(TS \\geq Z_{1 - \\alpha}\\) 样本数要足够 否则选 \\(t\\) 检验 通过 \\(\\alpha\\) 控制了 Type I error 但没控制 \\(\\beta\\) Type II error 所以结论为没有拒绝 \\(H_0\\) 而不是接受 \\(H_0\\) 拒绝 \\(H_0\\) 的值域为拒绝域 二项分布不易做正态假设可精确计算拒绝域 9.15 P 值 假定没有事发生 出现状况的可能性 先定义分布 然后计算相关统计量 对比常见阈值看数值是否够极端 阈值为达到显著性水平 与p值有区别 p值可设定任意显著性水平 小于就可以拒绝 两尾检验 单尾概率翻倍 独立于假设检验 但常常一起使用 9.16 功效 错误拒绝空假设的概率为功效（power） Power \\(= 1 - \\beta\\) 对 Type II error 的控制 正态分布假设下的推导 \\[ \\begin{align} 1 -\\beta &amp; = P\\left(\\frac{\\bar X - 30}{\\sigma /\\sqrt{n}} &gt; z_{1-\\alpha} ~|~ \\mu = \\mu_a \\right)\\\\ &amp; = P\\left(\\frac{\\bar X - \\mu_a + \\mu_a - 30}{\\sigma /\\sqrt{n}} &gt; z_{1-\\alpha} ~|~ \\mu = \\mu_a \\right)\\\\ \\\\ &amp; = P\\left(\\frac{\\bar X - \\mu_a}{\\sigma /\\sqrt{n}} &gt; z_{1-\\alpha} - \\frac{\\mu_a - 30}{\\sigma /\\sqrt{n}} ~|~ \\mu = \\mu_a \\right)\\\\ \\\\ &amp; = P\\left(Z &gt; z_{1-\\alpha} - \\frac{\\mu_a - 30}{\\sigma /\\sqrt{n}} ~|~ \\mu = \\mu_a \\right)\\\\ \\\\ \\end{align} \\] sigma &lt;- 10; mu_0 = 0; mu_a = 2; n &lt;- 100; alpha = .05 plot(c(-3, 6),c(0, dnorm(0)), type = &quot;n&quot;, frame = F, xlab = &quot;Z value&quot;, ylab = &quot;&quot;) xvals &lt;- seq(-3, 6, length = 1000) lines(xvals, dnorm(xvals), type = &quot;l&quot;, lwd = 3) lines(xvals, dnorm(xvals, mean = sqrt(n) * (mu_a - mu_0) / sigma), lwd =3) abline(v = qnorm(1 - alpha)) - 计算步骤 - 考虑 \\(H_0 : \\mu = \\mu_0\\) 与 \\(H_a : \\mu &gt; \\mu_0\\) 且在\\(H_a\\)下 \\(\\mu = \\mu_a\\) - 在 \\(H_0\\) 下统计量 \\(Z = \\frac{\\sqrt{n}(\\bar X - \\mu_0)}{\\sigma}\\) 符合 \\(N(0, 1)\\) - 在\\(H_a\\)下 \\(Z\\) 是 \\(N\\left( \\frac{\\sqrt{n}(\\mu_a - \\mu_0)}{\\sigma}, 1\\right)\\) - 如果 \\(Z &gt; Z_{1-\\alpha}\\) 拒绝空假设 也就是给定条件下功效不够 - 当检验 \\(H_a : \\mu &gt; \\mu_0\\), 如果功效为 \\(1 - \\beta\\) 那么 \\(1 - \\beta = P\\left(Z &gt; z_{1-\\alpha} - \\frac{\\mu_a - \\mu_0}{\\sigma /\\sqrt{n}} ~|~ \\mu = \\mu_a \\right) = P(Z &gt; z_{\\beta})\\) 也就是 \\(z_{1-\\alpha} - \\frac{\\sqrt{n}(\\mu_a - \\mu_0)}{\\sigma} = z_{\\beta}\\) - \\(\\mu_a\\), \\(\\sigma\\), \\(n\\), \\(\\beta\\), \\(\\mu_0\\), \\(\\alpha\\) 给定五个可解出剩余的 - 两尾检验考虑 \\(\\alpha / 2\\) - 功效在 \\(\\alpha\\) 提高 单尾检验功效高于两尾 \\(\\mu_1\\) 距离 \\(\\mu_0\\) 远功效大 样本数提高功效高 - 计算功效不需要特定样本 只需要指定 \\(\\frac{\\mu_a - \\mu_0}{\\sigma}\\) 也就是有效样本大小 无单位 - R 中使用 power.t.test 来计算 \\(t\\) 检验功效相关参数 指定多数求一个 9.17 多重比较 多次进行比较会导致错误率与校正出现问题 False positive rate 错误结果是显著的比率 \\(\\alpha\\) 样本数增大错误增加 Family wise error rate (FWER) 所有比较中至少一个假阳性比率 Bonferroni correction 假设你进行m次测试 控制 \\(\\alpha\\) 在某水平 计算所有测试的 \\(p\\) 值 将 \\(\\alpha\\) 设为 $ /m$ 所有测试都在这个置信度下进行 容易计算 过于保守 False discovery rate (FDR) 声称显著是错误的概率 \\(m\\) 次测试 水平 \\(\\alpha\\) 计算 \\(p\\) 值 排序 \\(P_{(i)} \\leq \\alpha \\times \\frac{i}{m}\\) 为显著 相对容易计算 不保守 允许一定的假阳性 调节p值 \\(P_i^{fwer} = \\max{m \\times P_i,1}\\) 类似FWER处理 \\(\\alpha\\) 的方式处理 \\(p\\) 按照正常 \\(\\alpha\\) 检测 一般情况对 \\(p\\) 值用 bonferroni/BH矫正就够了 对比间依赖强烈考虑 method=“BY” 多重比较从原理到应用 从实用角度分类 适合常见科研实验结果处理 9.18 重采样推断 jackknife 用来无偏估计偏差与标准误 每次估计删掉一个数据 \\(\\bar \\theta = \\frac{1}{n}\\sum_{i=1}^n \\hat \\theta_{i}\\) 偏差 \\((n - 1) \\left(\\bar \\theta - \\hat \\theta\\right)\\) 标准误 \\(\\left[\\frac{n-1}{n}\\sum_{i=1}^n (\\hat \\theta_i - \\bar\\theta )^2\\right]^{1/2}\\) 可用来估计分位数 是bootstrap的线性逼近 但性质不好 假观察量角度理解jackknife \\(\\mbox{Pseudo Obs} = n \\hat \\theta - (n - 1) \\hat \\theta_{i}\\) 生成原数据集 bootstrap 构建置信区间与求标准误 假定采样分布是总体分布 重采样估计统计量 有放回的重采样 \\(B\\) 次 \\(N\\) 个样本 得到估计统计量的一个分布 直接计算置信区间 非参方法 偏差小 进阶指南 置换检验 分组对比时取消原分组随机分组 重复进行 记录分组差异 对比原参数与置换后参数差异进行推断 "]
]
